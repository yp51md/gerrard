{"meta":{"title":"豆  荚","subtitle":null,"description":"我们竟安于大寒 七原色叠合的冰点 听任思想冻结，感情凝固……(杨牧)","author":"Gerrard","url":"https://github.com/yp51md/gerrard"},"pages":[{"title":"About me","date":"2019-02-09T12:50:08.000Z","updated":"2019-04-18T06:10:58.599Z","comments":true,"path":"about/index.html","permalink":"https://github.com/yp51md/gerrard/about/index.html","excerpt":"","text":"Who am I?主业物理，业余学点东西。一个爱折腾的小白。 What can you get? 一些记录和奇奇怪怪的想法。《力学》题解！想写一些东西给值得的人看。 Social Info&nbsp; github &nbsp; myfzjgnfz@outlook.com Do not go gentle into that good night!——Dylan Thomas"},{"title":"categories","date":"2019-04-14T12:32:54.000Z","updated":"2019-04-14T12:42:23.951Z","comments":true,"path":"categories/index.html","permalink":"https://github.com/yp51md/gerrard/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-04-14T12:29:43.000Z","updated":"2019-04-14T12:30:55.295Z","comments":true,"path":"tags/index.html","permalink":"https://github.com/yp51md/gerrard/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"头发的故事01","slug":"头发的故事01","date":"2019-04-18T06:16:01.000Z","updated":"2019-04-18T14:42:52.633Z","comments":true,"path":"2019/04/18/头发的故事01/","link":"","permalink":"https://github.com/yp51md/gerrard/2019/04/18/头发的故事01/","excerpt":"","text":"首先自打我想成为（zjg弗兰）面筋哥一样的男人之后，每天早上看到自己鸟窝一样的头发，就有一种想要全推掉的冲动。什么时候我才能有一头自然的柔顺丝滑的长发呢？QAQ 获得一根头发于是，现在我们获得了一根杨氏模量为$Y$的头发（图零）。假设myf的是全世界发质最好的男人，因此他的头发可以视为一根又黑又细的圆柱（图一）。 一小段头发取一小头发，进行分析。这一小段可视为一段圆弧（图二）。认为中心是不伸长的。因此距离圆心$x$的位置收到的应力为$P=Y\\frac{(L+x)\\Delta\\theta -L \\Delta\\theta}{L \\Delta\\theta}=Y\\frac{x}{L}$。 那么对整个面(图三)计算其对于中心轴$ L_0$ 的力矩。 $$ dM=2P \\sqrt { {R^{2} } - { x^{2} } }xdx $$积分：$$ M=\\int_{-R}^{R}2P \\sqrt { {R^{2} } - { x^{2} } }xdx$$$$ M=\\int_{-R}^{R}\\frac{2Y\\sqrt{R^2-x^2}x^2dx}{L}$$结果为:$$ M=Y \\frac{\\pi R^4}{4L} $$$L$是该段圆弧的曲率半径，$R$是头发的半径。至此头发的内部应力计算结束。 头发的形状第一次作死尝试本以为内力都算出来了，剩下的只要分析分析微元，解解微分方程就可以算出头发的形状。然后我就死了。查了一下，如果要算的话大概是这个画风。 你看看这是人算的吗？？ 第二次作死尝试根据参考文献[3]的启发，通过分形的方法数值计算。将长度为$h$的头发，分成$n$段，每一段可视为一段圆弧，也可以视为一段折线。分析第$i$段，在$i$处建系。$y$轴的方向是该段圆弧切线的方向。(图5)折线和y轴的夹角为$\\alpha_i$,这个角就是每一小段头发弯过去的角度。它们的累加为$\\beta$，是头发整体的转角，这是重力和折线的夹角。于是有$$ dmgsin\\beta\\frac{h}{2n}=M=Y \\frac{\\pi R^4}{4L} $$$$ dm=\\rho\\pi R^2\\frac{h}{n}$$计算曲率半径$L$（图6）$$L=\\frac{\\frac{h}{n}}{\\alpha_i}$$联立以上三式，得$$\\alpha_i=\\frac{2\\rho}{YR^2}(\\frac{h}{n})^3sin\\beta$$ 可以算了查得头发的杨氏模量约为$Y=4.39GPa$，直径取$D=0.070mm$, 则半径$R=0.035mm$。取头发的密度$\\rho=10^3kg/m^3$(印象里头发好像能浮在水上)。为什么查不到头发的密度呢？因为大家都在研究的头发的密度是以 $根/cm^2$ 为单位的。（滑稽）$t=\\frac{h}{n}$为一小段头发的长度，其越小越精确。下面是一个简单的c++程序1234567891011121314151617#include&lt;iostream&gt;#include&lt;cmath&gt;#define pi 3.1415926using namespace std;int main()&#123; double x=0,y=0.01; const double c=2*(1000)/(4.39*1e9*(0.000035)*(0.000035)); const double t=0.001; //取1mm为一段 int n=0; while (y&lt;(10.0/180.0*pi)) //弯曲10度 &#123; x=c*t*t*t*sin(y); y+=x; n++; &#125; cout &lt;&lt; n*t &lt;&lt; endl;&#125; 然后又死了尽管现在这个推导看起来很有道理，但实际跑出来的结果确实令人捉急。你甚至要把头发留到$7km$。（白发三千丈，缘愁似个长QAQ）当然可以做一些手脚，比如说少乘一个$t$，或者两个$t$,把杨氏模量改小一点，这样出来的结果都还是挺靠谱的。然并卵。 强行说明不过我们定性的看待那个式子还是能够有所发现。比方说：只要你有耐性，头发一定可以养到地上的。（这不是废话吗）头发越细的人越容易弯。？？？当然头发到末端也会变细的，所以尾端更容易弯。减小杨氏模量也是一个很好的办法。比如说选择潘婷？或者去一次阿玛尼，让您的头发的蛋白质变变结构，我保证这次不会让你尼玛啊。 最后靠重力把头发扳弯，其实是一件挺扯的事。（所以你上面的都在扯淡，小声）。看一下你掉下来的一根头发，这其实它本来就是弯的。：）知乎搜索“头发睡觉后变形，为什么洗过后恢复原型？”，有一些有意思的回答。下一个关于头发的故事，我准备聊聊对于我来说，“你变秃了，也变强了”的强行解释。 参考资料 [1]王敏中, 王敏中. 简支圆管在自重作用下的弯曲[J]. 力学与实践, 1983, 5(6). [2]张钟华. 简支圆管在重力作用下的应力状态[J]. 力学与实践, 1982, 4(1):32-35. [3]张杰, 林彬, 蔡文奇, et al. 弯曲树枝和分形树根的三维模拟[J]. 计算机应用, 2011, 31(06):1703-1705. [4]谢杨莹, 秦玉霞, 杨旭昕, et al. 拉伸法测头发丝杨氏模量实验装置的改装[J]. 物理实验, 2018(9):51-54.","categories":[{"name":"physics","slug":"physics","permalink":"https://github.com/yp51md/gerrard/categories/physics/"}],"tags":[{"name":"thoughts","slug":"thoughts","permalink":"https://github.com/yp51md/gerrard/tags/thoughts/"}]},{"title":"内容和形式感那一个更重要？","slug":"美的历程读书笔记_1","date":"2019-04-12T12:54:30.000Z","updated":"2019-04-18T06:10:14.643Z","comments":true,"path":"2019/04/12/美的历程读书笔记_1/","link":"","permalink":"https://github.com/yp51md/gerrard/2019/04/12/美的历程读书笔记_1/","excerpt":"","text":"首先求求你不要当一个懒狗。","categories":[{"name":"life","slug":"life","permalink":"https://github.com/yp51md/gerrard/categories/life/"}],"tags":[{"name":"thoughts","slug":"thoughts","permalink":"https://github.com/yp51md/gerrard/tags/thoughts/"},{"name":"reading","slug":"reading","permalink":"https://github.com/yp51md/gerrard/tags/reading/"},{"name":"美的历程","slug":"美的历程","permalink":"https://github.com/yp51md/gerrard/tags/美的历程/"}]},{"title":"程序设计基础的一些知识","slug":"程序设计基础","date":"2019-04-03T06:14:30.000Z","updated":"2019-04-30T12:21:21.211Z","comments":true,"path":"2019/04/03/程序设计基础/","link":"","permalink":"https://github.com/yp51md/gerrard/2019/04/03/程序设计基础/","excerpt":"","text":"首先用于记录一些程设课上的细节，以应对考试。 函数全局变量extern全局变量声明1234567int f()&#123; extern int x;&#125;int x=8;int main ()&#123; x++;&#125; //变量声明的作用是对变量进行操作类型的检查，并使可执行代码更加高效 作用域常见的两个错误1. 声明一个未被定义的全局标示符2. 声明了一个存在两个或两个以上定义的全局变量 全局域解析符 ::123456int x;void f()&#123; double x; x++; //double中的x； ::x++; //int中的x；&#125; 文件作用域用static修饰，定义某些东西只能在源文件中使用。1234567//file1.cppstatic int y=1;static void f();//file2.cppextern int y;extern void f(); 编译的时候不会出错，但是链接的时候会报错。 也可以用namespace达到同样的效果。1234namespace &#123; int y; void f();&#125; 变量的生存区123auto int x; // 自动的生存期，auto可忽略static int y; // 静态的生存期register int z; // 建议将空间分配到cpu的寄存器中 函数中定义static仅仅会在第一次调用的时候初始化，并且在函数调用完成之后不会被收回内存空间。1234567891011#include &lt;iostream&gt;using namespace std;int f()&#123; static int y=1; y++; cout &lt;&lt; y &lt;&lt; \" \";&#125;int main ()&#123; f(); f();&#125; 结果为 2 3 用static产生随机数12345unsigned int random()&#123; static unsigned int seed=1; seed =(25173*seed+13849)%65536; return seed;&#125;//25173,13849,65536保证seed不越界 为了解决小函数调用时效率不高的问题123inline int f(int a)&#123; cout &lt;&lt; a;&#125; 通过inline关键词建议编译程序将函数体展开。 带参数的宏1#define swap(x,y) (int temp=a;a=b;b=temp;) 宏定义是字符串替换！a+b*a-b 带有缺省值的函数1void print(int valve, int base=10); 调用12print(10); //base=10;print(10,2);//base=2; 注意：带有缺省值的函数放在最后面。 重载函数有5种匹配原则： 精确匹配 提升匹配 标准转换匹配 自定义转换匹配 匹配失败 符合数据类型联合类型语法与struct一样。1234567891011121314151617181920struct circle &#123; double x,y,r;&#125;enum shape &#123;circle,triangle&#125;struct trianganle &#123; double x1,y1,z1;&#125;union figure&#123; circle circle; triangle triangle;&#125;struct real_figure&#123; figureshape shape; figure figure;&#125;real_figure[MAX];real_figure[index].shape=\"circle\";real_figure[index].figure.circle.x=1;real_figure[index].figure.circle.y=1;real_figure[index].figure.circle.z=1; 一些写法for和cin1for(cin&gt;&gt;n;n!='#';cin&gt;&gt;n) 对浮点数进行比较1234double x,y;fabs(x-y)&lt;1e-6;//x==y;fabs(x-y)&lt;1e-6;//x!=y//fab是求浮点绝对值的函数 sqrt12int n;double j=sqrt(float(n)); 用if控制条件编译123456789#define program=1#if program==1//应该编译的内容#endif #if program==2//不会被编译#endif 多平台12345678#ifdef UNIX ...... //适合于UNIX环境的代码#elif WINDOWS ...... //适合于WINDOWS环境的代码#else ...... //适合于其它环境的代码#endif...... //适合于各种环境的公共代码 枚举型12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;enum COLOR&#123;red,green,blue&#125;;ostream&amp; operator &lt;&lt; (ostream&amp; output,enum COLOR &amp; c) //定义运算符“&lt;&lt;”重载函数&#123; switch (c) &#123; case red:output &lt;&lt; \"red\";break; case green:output &lt;&lt; \"green\";break; case blue:output &lt;&lt; \"blue\";break; &#125; return output;&#125;int main()&#123; enum COLOR color=red; //用for循环枚举 for(int i=0;i&lt;=2;i++)&#123; cout &lt;&lt; color; cout &lt;&lt; endl; color=(COLOR)(color+1); &#125; return 0;&#125; 向函数传递二维数组1234int sum(int x[][5],int lin)//需要写入行数和列数&#123; &#125; 将二维数组降维1234int sum(int x[],int lin)&#123;&#125;sum(x[0],lin*row);//因为是二维数组是线性存储的。 strecmp12int strcmp(const char * a,const char *b)x=strcmp(str1,str2);//str1&gt;str2 x&gt;0; = x=0; &lt; x&lt; =; 参考资料 陈家骏、郑滔，《程序设计教程－－用C++语言编程》（第3版），机械工业出版社，2015","categories":[{"name":"cs","slug":"cs","permalink":"https://github.com/yp51md/gerrard/categories/cs/"}],"tags":[{"name":"resources","slug":"resources","permalink":"https://github.com/yp51md/gerrard/tags/resources/"}]},{"title":"ubuntu18.04安装总结","slug":"ubuntu18-04安装总结","date":"2019-02-22T01:57:18.000Z","updated":"2019-04-14T12:47:17.675Z","comments":true,"path":"2019/02/22/ubuntu18-04安装总结/","link":"","permalink":"https://github.com/yp51md/gerrard/2019/02/22/ubuntu18-04安装总结/","excerpt":"","text":"首先由于linux对硬件的支持不够友好，导致出了很多奇奇怪怪的问题。总结一下。方便自己再次重装（大雾） 配置Lenovo-Legion-Y7000cpu: Intel Core™ i5-8300Hgpu: GeForce GTX 1050 安装流程制作U盘启动器官网文档 进入界面后卡死原因是ubuntu对NVIDIA的显卡驱动支持不好，默认启动的F12 从U盘启动 在grub界面按 e 修改quite splash —为quite splash nomodeset通过集显启动。 解决对高通网卡的禁用在shell中输入 sudo modprobe -r ideapad_laptop暂时可以使用无线网卡 分盘策略 盘符 大小 格式 \\ 固态上40G ext4 \\boot 1G ext4 \\swap 2G swap \\home 机械上50G ext4 将启动引导挂在 \\boot上。之后下一步即可。 安装完成之后进入系统和上述操作一样使用独显和启用无线网卡。 更新打开软件更新器(update),换源，更新软件。 无线网卡在shell中： sudo gedit /etc/modprobe.d/ideapad.conf 在打开的文件中输入： blacklist ideapad_laptop 重启后就可以打开WiFi 安装NVIDIA显卡禁用自带的 nouveau nvidia驱动在shell中 sudo gedit /etc/modprobe.d/lacklist-nouveau.conf 添加 blacklist nouveauoptions nouveau modeset=0 更新 sudo update-initramfs -u 后重启 查询显卡型号shell: lspci -vnn | grep VGA 在英伟达官网 查找驱动型号 安装显卡驱动 sudo add-apt-repository ppa:graphics-drivers/ppasudo apt-get updatesudo apt-get install nvidia-** nvidia-*是查找到的型号安装完成后重启。重启后用 nvidia-smi 查看是否安装成功 以上","categories":[{"name":"cs","slug":"cs","permalink":"https://github.com/yp51md/gerrard/categories/cs/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://github.com/yp51md/gerrard/tags/ubuntu/"},{"name":"resources","slug":"resources","permalink":"https://github.com/yp51md/gerrard/tags/resources/"}]}]}